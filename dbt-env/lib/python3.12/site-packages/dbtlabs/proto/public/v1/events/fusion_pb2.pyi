"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import dbtlabs.proto.public.v1.events.vortex_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _OnboardingScreen:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _OnboardingScreenEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_OnboardingScreen.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SCREEN_UNSPECIFIED: _OnboardingScreen.ValueType  # 0
    WELCOME: _OnboardingScreen.ValueType  # 1
    PROFILE_CHECK: _OnboardingScreen.ValueType  # 2
    PROFILE_FOUND: _OnboardingScreen.ValueType  # 3
    PROFILE_SETUP: _OnboardingScreen.ValueType  # 4
    LINK_ACCOUNT: _OnboardingScreen.ValueType  # 5
    DBT_PARSE: _OnboardingScreen.ValueType  # 6
    PARSE_ERROR_AUTOFIX: _OnboardingScreen.ValueType  # 7
    DBT_PARSE_RETRY: _OnboardingScreen.ValueType  # 8
    PARSE_ERROR_FAIL: _OnboardingScreen.ValueType  # 9
    COMPILE_NO_SA: _OnboardingScreen.ValueType  # 10
    COMPILE_NO_SA_FAIL: _OnboardingScreen.ValueType  # 11
    COMPILE: _OnboardingScreen.ValueType  # 12
    COMPILE_FAIL: _OnboardingScreen.ValueType  # 13
    SUCCESS: _OnboardingScreen.ValueType  # 14
    AGENTIC_AUTOFIX: _OnboardingScreen.ValueType  # 15
    TRY_AGENTIC_AUTOFIX: _OnboardingScreen.ValueType  # 16
    DOWNLOAD_AGENTS_MD: _OnboardingScreen.ValueType  # 17

class OnboardingScreen(_OnboardingScreen, metaclass=_OnboardingScreenEnumTypeWrapper): ...

SCREEN_UNSPECIFIED: OnboardingScreen.ValueType  # 0
WELCOME: OnboardingScreen.ValueType  # 1
PROFILE_CHECK: OnboardingScreen.ValueType  # 2
PROFILE_FOUND: OnboardingScreen.ValueType  # 3
PROFILE_SETUP: OnboardingScreen.ValueType  # 4
LINK_ACCOUNT: OnboardingScreen.ValueType  # 5
DBT_PARSE: OnboardingScreen.ValueType  # 6
PARSE_ERROR_AUTOFIX: OnboardingScreen.ValueType  # 7
DBT_PARSE_RETRY: OnboardingScreen.ValueType  # 8
PARSE_ERROR_FAIL: OnboardingScreen.ValueType  # 9
COMPILE_NO_SA: OnboardingScreen.ValueType  # 10
COMPILE_NO_SA_FAIL: OnboardingScreen.ValueType  # 11
COMPILE: OnboardingScreen.ValueType  # 12
COMPILE_FAIL: OnboardingScreen.ValueType  # 13
SUCCESS: OnboardingScreen.ValueType  # 14
AGENTIC_AUTOFIX: OnboardingScreen.ValueType  # 15
TRY_AGENTIC_AUTOFIX: OnboardingScreen.ValueType  # 16
DOWNLOAD_AGENTS_MD: OnboardingScreen.ValueType  # 17
Global___OnboardingScreen: typing_extensions.TypeAlias = OnboardingScreen

class _OnboardingAction:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _OnboardingActionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_OnboardingAction.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ACTION_UNSPECIFIED: _OnboardingAction.ValueType  # 0
    INITIATED: _OnboardingAction.ValueType  # 1
    """flow start (WELCOME)"""
    SCREEN_SHOWN: _OnboardingAction.ValueType  # 2
    """screen displayed"""
    RUN_STARTED: _OnboardingAction.ValueType  # 3
    """parse/compile began"""
    RUN_FINISHED: _OnboardingAction.ValueType  # 4
    """parse/compile ended (use success)"""
    STEP_COMPLETED: _OnboardingAction.ValueType  # 5
    """checkpoint reached (use success)"""
    STEP_FAILED: _OnboardingAction.ValueType  # 6
    """explicit failure"""

class OnboardingAction(_OnboardingAction, metaclass=_OnboardingActionEnumTypeWrapper): ...

ACTION_UNSPECIFIED: OnboardingAction.ValueType  # 0
INITIATED: OnboardingAction.ValueType  # 1
"""flow start (WELCOME)"""
SCREEN_SHOWN: OnboardingAction.ValueType  # 2
"""screen displayed"""
RUN_STARTED: OnboardingAction.ValueType  # 3
"""parse/compile began"""
RUN_FINISHED: OnboardingAction.ValueType  # 4
"""parse/compile ended (use success)"""
STEP_COMPLETED: OnboardingAction.ValueType  # 5
"""checkpoint reached (use success)"""
STEP_FAILED: OnboardingAction.ValueType  # 6
"""explicit failure"""
Global___OnboardingAction: typing_extensions.TypeAlias = OnboardingAction

@typing.final
class AdapterInfo(google.protobuf.message.Message):
    """
    RFC 2119 Expectations for using these events:

    1. When the Fusion process starts it MUST emit the `Invocation` event once at the start of the process before any other events
    a. The `invocation_id` field MUST be set to a globally unique ID
    b. All fields that have a `Required` comment MUST be set
    c. All other fields without a `Required` comment MAY be set and are optional if they can be found
    2. After the Fusion emits the `Invocation` event it MAY emit the `v1.events.fusion.CloudInvocation` at the start of the process before any other events
    3. Fusion MUST emit a `RunModel` event for every model in the project that is part of the Node Selector
    a. Fusion MAY omit `RunModel` events for nodes that are not part of the Node Selector used https://docs.getdbt.com/reference/node-selection/syntax

    Adapter Info Event is responsible for foundational adapter information.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENRICHMENT_FIELD_NUMBER: builtins.int
    EVENT_ID_FIELD_NUMBER: builtins.int
    INVOCATION_ID_FIELD_NUMBER: builtins.int
    ADAPTER_TYPE_FIELD_NUMBER: builtins.int
    ADAPTER_UNIQUE_ID_FIELD_NUMBER: builtins.int
    event_id: builtins.str
    """event_id is the unique identifier for this event. It is a generated UUID."""
    invocation_id: builtins.str
    """A foreign key to the Invocation message that was emitted at the
    start of the fusion process.
    Required.
    """
    adapter_type: builtins.str
    """adapter_type is the plain string name for the dbt adapter that's used by the
    project. Examples could include: "bigquery", "snowflake", "redshift", "postgres", etc.
    """
    adapter_unique_id: builtins.str
    """adapter_unique_id is the unique identifier of a project's warehouse credentials.
    For supported warehouses, we create an MD5 hash of the connection string.
    The specific string varies per adapter_type.
    """
    @property
    def enrichment(self) -> dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment:
        """This field is a toggle to enable enrichment of the message by the Vortex service."""

    def __init__(
        self,
        *,
        enrichment: dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment | None = ...,
        event_id: builtins.str = ...,
        invocation_id: builtins.str = ...,
        adapter_type: builtins.str = ...,
        adapter_unique_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["enrichment", b"enrichment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["adapter_type", b"adapter_type", "adapter_unique_id", b"adapter_unique_id", "enrichment", b"enrichment", "event_id", b"event_id", "invocation_id", b"invocation_id"]) -> None: ...

Global___AdapterInfo: typing_extensions.TypeAlias = AdapterInfo

@typing.final
class AdapterInfoV2(google.protobuf.message.Message):
    """Adapter Info V2 Event was created when we needed to collect more information
    about the adapter. Unlike AdapterInfo above, this event is tied to RunModel
    events. Here we're able to collect adapter-specific information at the
    individual model level. This was first created when we started to collect
    information on which models were Iceberg-powered.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ModelAdapterDetailsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    ENRICHMENT_FIELD_NUMBER: builtins.int
    EVENT_ID_FIELD_NUMBER: builtins.int
    RUN_MODEL_ID_FIELD_NUMBER: builtins.int
    ADAPTER_NAME_FIELD_NUMBER: builtins.int
    BASE_ADAPTER_VERSION_FIELD_NUMBER: builtins.int
    ADAPTER_VERSION_FIELD_NUMBER: builtins.int
    MODEL_ADAPTER_DETAILS_FIELD_NUMBER: builtins.int
    event_id: builtins.str
    """event_id is the unique identifier for this event. It is a generated UUID."""
    run_model_id: builtins.str
    """A foreign key to the RunModel message that was emitted at each instance
    of an individual model being run.
    """
    adapter_name: builtins.str
    """This reflects the adapter name used when they ran a given model."""
    base_adapter_version: builtins.str
    """This reflects the simplified semantic version of an adapter that was used
    when they ran a given model. ex. 1.9.0
    """
    adapter_version: builtins.str
    """This reflects the full adapter version used when they ran a given model."""
    @property
    def enrichment(self) -> dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment:
        """This field is a toggle to enable enrichment of the message by the Vortex service."""

    @property
    def model_adapter_details(self) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """This is a flexible key-value pair that can be used to store any additional
        model adapter information. Today this is used to store two pieces of
        information: the model_adapter_type (the adapter_name that was used for
        that specific model) and the model_adapter_table_format (Iceberg or
        something else).
        """

    def __init__(
        self,
        *,
        enrichment: dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment | None = ...,
        event_id: builtins.str = ...,
        run_model_id: builtins.str = ...,
        adapter_name: builtins.str = ...,
        base_adapter_version: builtins.str = ...,
        adapter_version: builtins.str = ...,
        model_adapter_details: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["enrichment", b"enrichment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["adapter_name", b"adapter_name", "adapter_version", b"adapter_version", "base_adapter_version", b"base_adapter_version", "enrichment", b"enrichment", "event_id", b"event_id", "model_adapter_details", b"model_adapter_details", "run_model_id", b"run_model_id"]) -> None: ...

Global___AdapterInfoV2: typing_extensions.TypeAlias = AdapterInfoV2

@typing.final
class Invocation(google.protobuf.message.Message):
    """Invocation Event is emitted by dbt when a user runs a command and begins to
    emit basic environment information out that can be referred to later on by
    other events that are emitted. This event then fires off a second time when
    the invocation has completed. Upon completion, we get more information about
    the end state of this action.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENRICHMENT_FIELD_NUMBER: builtins.int
    EVENT_ID_FIELD_NUMBER: builtins.int
    INVOCATION_ID_FIELD_NUMBER: builtins.int
    PROJECT_ID_FIELD_NUMBER: builtins.int
    USER_ID_FIELD_NUMBER: builtins.int
    COMMAND_FIELD_NUMBER: builtins.int
    PROGRESS_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    RESULT_TYPE_FIELD_NUMBER: builtins.int
    GIT_COMMIT_SHA_FIELD_NUMBER: builtins.int
    event_id: builtins.str
    """event_id is the unique identifier for this event. It is a generated UUID.
    Required.
    """
    invocation_id: builtins.str
    """This is the globally unique identifier for this invocation event.
    It is emitted once during the lifetime of the fusion process at the
    beginning and referred to by other messages using this ID.
    Required.
    """
    project_id: builtins.str
    """project_id is the MD5 hash of the project name that's supplied in the
    dbt_project.yml file. This is originally the primary identifier for our anonymous
    usage tracking. Today we couple this with the AdapterInfo adapter_unique_id.
    """
    user_id: builtins.str
    """user_id is the UUID generated to identify a unique user. We store a cookie
    or token in the user's local directory which we use to maintain user information
    across sessions. This is usually found in ~/.dbt/.user.yml.
    """
    command: builtins.str
    """The full string of the command that was run."""
    progress: builtins.str
    """A string that indicates whether the event represents the start or end of an
    invocation. The valid values for this are:

     start
     end
     invalid
     ok
    """
    version: builtins.str
    """The version of dbt that was used to run this command."""
    result_type: builtins.str
    """The exit state of an invocation's start or end event. The valid values for this are:

     started
     ok
     invalid_profile
     error
    """
    git_commit_sha: builtins.str
    """The SHA of the git commit of the dbt project being run if it is found.
    If there are changes that aren't committed we may also want to have a
    git_commit_dirty boolean to indicate there are some staged or unstaged
    changes.  In the RunModel message there is also a hashed_contents which
    gives a hash of the model being run which may be finer granularity than
    at a project level.
    """
    @property
    def enrichment(self) -> dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment:
        """This field is a toggle to enable enrichment of the message by the Vortex service."""

    def __init__(
        self,
        *,
        enrichment: dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment | None = ...,
        event_id: builtins.str = ...,
        invocation_id: builtins.str = ...,
        project_id: builtins.str = ...,
        user_id: builtins.str = ...,
        command: builtins.str = ...,
        progress: builtins.str = ...,
        version: builtins.str = ...,
        result_type: builtins.str = ...,
        git_commit_sha: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["enrichment", b"enrichment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["command", b"command", "enrichment", b"enrichment", "event_id", b"event_id", "git_commit_sha", b"git_commit_sha", "invocation_id", b"invocation_id", "progress", b"progress", "project_id", b"project_id", "result_type", b"result_type", "user_id", b"user_id", "version", b"version"]) -> None: ...

Global___Invocation: typing_extensions.TypeAlias = Invocation

@typing.final
class InvocationEnv(google.protobuf.message.Message):
    """Invocation Environment Event is the primary way we are able to associate
    invocation telemetry data with our dbt Cloud information. Values are supplied
    here whenever dbt is run in a cloud environment.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENRICHMENT_FIELD_NUMBER: builtins.int
    EVENT_ID_FIELD_NUMBER: builtins.int
    INVOCATION_ID_FIELD_NUMBER: builtins.int
    ENVIRONMENT_FIELD_NUMBER: builtins.int
    event_id: builtins.str
    """event_id is the unique identifier for this event. It is a generated UUID."""
    invocation_id: builtins.str
    """A foreign key to the Invocation message that was emitted at the
    start of the fusion process.
    """
    environment: builtins.str
    """This is a string that indicates the environment in which the invocation is
    running. Our primary use case here is to pass along dbt Cloud context with
    the invocation event so we can associate the invocation with a specific
    dbt Cloud activity and account. Different cloud services have used different
    string formats and IDs provided.
    """
    @property
    def enrichment(self) -> dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment:
        """This field is a toggle to enable enrichment of the message by the Vortex service."""

    def __init__(
        self,
        *,
        enrichment: dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment | None = ...,
        event_id: builtins.str = ...,
        invocation_id: builtins.str = ...,
        environment: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["enrichment", b"enrichment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["enrichment", b"enrichment", "environment", b"environment", "event_id", b"event_id", "invocation_id", b"invocation_id"]) -> None: ...

Global___InvocationEnv: typing_extensions.TypeAlias = InvocationEnv

@typing.final
class PackageInstall(google.protobuf.message.Message):
    """Package Install Event is emitted when dbt deps (or other commands that
    trigger packages to be installed) is run.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENRICHMENT_FIELD_NUMBER: builtins.int
    EVENT_ID_FIELD_NUMBER: builtins.int
    INVOCATION_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    event_id: builtins.str
    """event_id is the unique identifier for this event. It is a generated UUID."""
    invocation_id: builtins.str
    """A foreign key to the Invocation message that was emitted at the
    start of the fusion process.
    """
    name: builtins.str
    """plain string name of a pakage that was installed. This is often the same
    or similar to the git repository name of that package.
    """
    source: builtins.str
    """plain string source of the package. This is also referred to as the
    installation method in our internal analytics. This is based on the syntax
    used in packages.yml file.
    """
    version: builtins.str
    """either a semantic version of the package (if installed through the hub) or
    a git commit hash (if installed through git).
    """
    @property
    def enrichment(self) -> dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment:
        """This field is a toggle to enable enrichment of the message by the Vortex service."""

    def __init__(
        self,
        *,
        enrichment: dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment | None = ...,
        event_id: builtins.str = ...,
        invocation_id: builtins.str = ...,
        name: builtins.str = ...,
        source: builtins.str = ...,
        version: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["enrichment", b"enrichment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["enrichment", b"enrichment", "event_id", b"event_id", "invocation_id", b"invocation_id", "name", b"name", "source", b"source", "version", b"version"]) -> None: ...

Global___PackageInstall: typing_extensions.TypeAlias = PackageInstall

@typing.final
class ResourceCounts(google.protobuf.message.Message):
    """Resource Counts Events fire after an invocation event to give a count of all
    the resources that were used in the invocation. Note that this includes all
    the resources in the active project, including those from installed packages
    and (in the case of macros) from the global dbt project. This will show all
    resources available, regardless of if they are run or not.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENRICHMENT_FIELD_NUMBER: builtins.int
    EVENT_ID_FIELD_NUMBER: builtins.int
    INVOCATION_ID_FIELD_NUMBER: builtins.int
    MODELS_FIELD_NUMBER: builtins.int
    TESTS_FIELD_NUMBER: builtins.int
    SNAPSHOTS_FIELD_NUMBER: builtins.int
    ANALYSES_FIELD_NUMBER: builtins.int
    MACROS_FIELD_NUMBER: builtins.int
    OPERATIONS_FIELD_NUMBER: builtins.int
    SEEDS_FIELD_NUMBER: builtins.int
    SOURCES_FIELD_NUMBER: builtins.int
    EXPOSURES_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    GROUPS_FIELD_NUMBER: builtins.int
    UNIT_TESTS_FIELD_NUMBER: builtins.int
    SEMANTIC_MODELS_FIELD_NUMBER: builtins.int
    SAVED_QUERIES_FIELD_NUMBER: builtins.int
    event_id: builtins.str
    """event_id is the unique identifier for this event. It is a generated UUID."""
    invocation_id: builtins.str
    """A foreign key to the Invocation message that was emitted at the
    start of the fusion process.
    """
    models: builtins.int
    """total count of models in the project."""
    tests: builtins.int
    """total count of data tests (originally just tests) in the project."""
    snapshots: builtins.int
    """total count of snapshots in the project."""
    analyses: builtins.int
    """total count of analysis queries in the project."""
    macros: builtins.int
    """total count of macros in the project."""
    operations: builtins.int
    """total count of operations in the project."""
    seeds: builtins.int
    """total count of seeds in the project."""
    sources: builtins.int
    """total count of sources in the project."""
    exposures: builtins.int
    """total count of exposures in the project."""
    metrics: builtins.int
    """total count of metrics in the project."""
    groups: builtins.int
    """total count of groups in the project."""
    unit_tests: builtins.int
    """total count of unit tests in the project."""
    semantic_models: builtins.int
    """total count of semantic models in the project."""
    saved_queries: builtins.int
    """total count of saved queries in the project."""
    @property
    def enrichment(self) -> dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment:
        """This field is a toggle to enable enrichment of the message by the Vortex service."""

    def __init__(
        self,
        *,
        enrichment: dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment | None = ...,
        event_id: builtins.str = ...,
        invocation_id: builtins.str = ...,
        models: builtins.int = ...,
        tests: builtins.int = ...,
        snapshots: builtins.int = ...,
        analyses: builtins.int = ...,
        macros: builtins.int = ...,
        operations: builtins.int = ...,
        seeds: builtins.int = ...,
        sources: builtins.int = ...,
        exposures: builtins.int = ...,
        metrics: builtins.int = ...,
        groups: builtins.int = ...,
        unit_tests: builtins.int = ...,
        semantic_models: builtins.int = ...,
        saved_queries: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["enrichment", b"enrichment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["analyses", b"analyses", "enrichment", b"enrichment", "event_id", b"event_id", "exposures", b"exposures", "groups", b"groups", "invocation_id", b"invocation_id", "macros", b"macros", "metrics", b"metrics", "models", b"models", "operations", b"operations", "saved_queries", b"saved_queries", "seeds", b"seeds", "semantic_models", b"semantic_models", "snapshots", b"snapshots", "sources", b"sources", "tests", b"tests", "unit_tests", b"unit_tests"]) -> None: ...

Global___ResourceCounts: typing_extensions.TypeAlias = ResourceCounts

@typing.final
class RunModel(google.protobuf.message.Message):
    """Run Model Event will be emitted when Fusion runs a model or skips a model because
    it determines it does not need to be run. The Account Identifier and Project Identifier
    can be found by joining this message on the Invocation message specified in the invocation_id
    field.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENRICHMENT_FIELD_NUMBER: builtins.int
    EVENT_ID_FIELD_NUMBER: builtins.int
    INVOCATION_ID_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    TOTAL_FIELD_NUMBER: builtins.int
    EXECUTION_TIME_FIELD_NUMBER: builtins.int
    RUN_STATUS_FIELD_NUMBER: builtins.int
    RUN_SKIPPED_FIELD_NUMBER: builtins.int
    MODEL_MATERIALIZATION_FIELD_NUMBER: builtins.int
    MODEL_INCREMENTAL_STRATEGY_FIELD_NUMBER: builtins.int
    MODEL_ID_FIELD_NUMBER: builtins.int
    HASHED_CONTENTS_FIELD_NUMBER: builtins.int
    LANGUAGE_FIELD_NUMBER: builtins.int
    HAS_GROUP_FIELD_NUMBER: builtins.int
    CONTRACT_ENFORCED_FIELD_NUMBER: builtins.int
    ACCESS_FIELD_NUMBER: builtins.int
    VERSIONED_FIELD_NUMBER: builtins.int
    RUN_SKIPPED_REASON_FIELD_NUMBER: builtins.int
    RUN_MODEL_ID_FIELD_NUMBER: builtins.int
    RESOURCE_TYPE_FIELD_NUMBER: builtins.int
    event_id: builtins.str
    """event_id is the unique identifier for this event. It is a generated UUID."""
    invocation_id: builtins.str
    """A foreign key to the Invocation message that was emitted at the
    start of the fusion process.
    """
    index: builtins.int
    """the numerical index of that model with respect to the total models being run"""
    total: builtins.int
    """the total number of models being run in this invocation"""
    execution_time: builtins.float
    """the time it took for a model to execute in seconds. This should mirror what
    is displayed in the dbt output logs next to each model.
    """
    run_status: builtins.str
    """success or failure status of that model's run. This mirrors what is displayed
    in the dbt output logs next to each model. Ex. "SUCCESS 1", "INSERT 1", "INSERT 23", etc.
    """
    run_skipped: builtins.bool
    """whether or not the model was skipped. If the run was skipped the reason it was
    skipped is indicated by the value of the run_skipped_reason field.
    """
    model_materialization: builtins.str
    """the materialization strategy used for that model"""
    model_incremental_strategy: builtins.str
    """the incremental strategy used for that model (ex. append, merge, etc.)"""
    model_id: builtins.str
    """unique identifier for the model (I believe an MD5 hash of the model name)"""
    hashed_contents: builtins.str
    """MD5 hash of the model's contents. This is used to determine if the model
    has changed since the last time it was run.
    """
    language: builtins.str
    """the language used to write the model (ex. sql, python)"""
    has_group: builtins.bool
    """whether or not the model is in a group"""
    contract_enforced: builtins.bool
    """whether or not the model is contract enforced"""
    access: builtins.str
    """the access level of the model (ex. public, private, etc.)"""
    versioned: builtins.bool
    """whether or not the model is versioned"""
    run_skipped_reason: builtins.str
    """A reason for why the model was skipped. The valid values for this are:

     cost_avoidance
     upstream_failed
    """
    run_model_id: builtins.str
    """A globally unique ID that is emitted at each instance of an individual
    model being run.
    """
    resource_type: builtins.str
    """The resource type of the node (model, test, etc.)"""
    @property
    def enrichment(self) -> dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment:
        """This field is a toggle to enable enrichment of the message by the Vortex service."""

    def __init__(
        self,
        *,
        enrichment: dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment | None = ...,
        event_id: builtins.str = ...,
        invocation_id: builtins.str = ...,
        index: builtins.int = ...,
        total: builtins.int = ...,
        execution_time: builtins.float = ...,
        run_status: builtins.str = ...,
        run_skipped: builtins.bool = ...,
        model_materialization: builtins.str = ...,
        model_incremental_strategy: builtins.str = ...,
        model_id: builtins.str = ...,
        hashed_contents: builtins.str = ...,
        language: builtins.str = ...,
        has_group: builtins.bool = ...,
        contract_enforced: builtins.bool = ...,
        access: builtins.str = ...,
        versioned: builtins.bool = ...,
        run_skipped_reason: builtins.str = ...,
        run_model_id: builtins.str = ...,
        resource_type: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["enrichment", b"enrichment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["access", b"access", "contract_enforced", b"contract_enforced", "enrichment", b"enrichment", "event_id", b"event_id", "execution_time", b"execution_time", "has_group", b"has_group", "hashed_contents", b"hashed_contents", "index", b"index", "invocation_id", b"invocation_id", "language", b"language", "model_id", b"model_id", "model_incremental_strategy", b"model_incremental_strategy", "model_materialization", b"model_materialization", "resource_type", b"resource_type", "run_model_id", b"run_model_id", "run_skipped", b"run_skipped", "run_skipped_reason", b"run_skipped_reason", "run_status", b"run_status", "total", b"total", "versioned", b"versioned"]) -> None: ...

Global___RunModel: typing_extensions.TypeAlias = RunModel

@typing.final
class Onboarding(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENRICHMENT_FIELD_NUMBER: builtins.int
    EVENT_ID_FIELD_NUMBER: builtins.int
    INVOCATION_ID_FIELD_NUMBER: builtins.int
    SCREEN_FIELD_NUMBER: builtins.int
    ACTION_FIELD_NUMBER: builtins.int
    SUCCESS_FIELD_NUMBER: builtins.int
    USER_ID_FIELD_NUMBER: builtins.int
    event_id: builtins.str
    """Unique identifier for this event (UUID).
    Required.
    """
    invocation_id: builtins.str
    """Globally unique identifier for the fusion invocation.
    Required.
    """
    screen: Global___OnboardingScreen.ValueType
    """Onboarding semantics.
    Which screen/step
    """
    action: Global___OnboardingAction.ValueType
    """What happened on that screen"""
    success: builtins.bool
    """Only for RUN_FINISHED/STEP_COMPLETED; ignored otherwise"""
    user_id: builtins.str
    """user_id is the UUID generated to identify a unique user. We store a cookie
    or token in the user's local directory which we use to maintain user information
    across sessions. This is usually found in ~/.dbt/.user.yml.
    """
    @property
    def enrichment(self) -> dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment:
        """This field is a toggle to enable enrichment of the message by the Vortex service."""

    def __init__(
        self,
        *,
        enrichment: dbtlabs.proto.public.v1.events.vortex_pb2.VortexMessageEnrichment | None = ...,
        event_id: builtins.str = ...,
        invocation_id: builtins.str = ...,
        screen: Global___OnboardingScreen.ValueType = ...,
        action: Global___OnboardingAction.ValueType = ...,
        success: builtins.bool = ...,
        user_id: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["enrichment", b"enrichment"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["action", b"action", "enrichment", b"enrichment", "event_id", b"event_id", "invocation_id", b"invocation_id", "screen", b"screen", "success", b"success", "user_id", b"user_id"]) -> None: ...

Global___Onboarding: typing_extensions.TypeAlias = Onboarding
